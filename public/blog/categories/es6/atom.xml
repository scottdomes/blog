<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Es6 | Scott Domes | Web Developer]]></title>
  <link href="http://scottdomes.com/blog/categories/es6/atom.xml" rel="self"/>
  <link href="http://scottdomes.com/"/>
  <updated>2017-08-11T17:30:54-07:00</updated>
  <id>http://scottdomes.com/</id>
  <author>
    <name><![CDATA[Scott Domes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Benchmark React Components: The Quick and Dirty Guide]]></title>
    <link href="http://scottdomes.com/blog/how-to-benchmark-react-components-the-quick-and-dirty-guide/"/>
    <updated>2017-08-11T16:50:37-07:00</updated>
    <id>http://scottdomes.com/blog/how-to-benchmark-react-components-the-quick-and-dirty-guide</id>
    <content type="html"><![CDATA[<p>A React Component works hard. As the user manipulates the state of the
application, it may re-render 5, 10, 100 times. Sometimes, that’s a good thing.
But if you don’t understand what is causing the re-renders, and whether they are
necessary, your app could suffer serious slowdown.</p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*VDZqVFTK09inhHpjKJpXpw.png" alt="" /></p>

<!--more-->


<h3>A Tale of Two Tables</h3>

<p>A few months after I started at MuseFind, we embarked on a rewrite of our
internal software. The key piece in this application was a table that allowed
our customer success team toquickly edit, add, and manage collaborations across
all influencer marketing campaigns on our platform.</p>

<p>The purpose of this rewrite was to improve our team’s efficiency — speed was the
name of the game. But as the table grew in complexity (more and more
subcomponents for each row, with inputs and date inputs and buttons), it became
more and more slow. Slow to update, slow to reload — just a pain to use.</p>

<p>The solution was to carefully measure the render time of the subcomponents and
of the table as a whole, and then begin experimenting. Over time, we managed to
cut the table render time to a third of what it was.</p>

<p>In this article I’ll take you on a quick tour of React’s performance tools, and
how to eliminate wasted renders.</p>

<p>Let’s get started.</p>

<h3>How To Benchmark A React Component</h3>

<p>We’ll use a simple example: an app that renders a list of 10,000 numbers.</p>

<p>Half the numbers in the list — 1 to 5,000- are simply generated by incrementing.
The other half, in a separate array, are generated by incrementing and then
multiplying by a number stored in the app’s state.</p>

<p>So if the <em>this.state.multiplier</em> is 2, the second array would be 2, 4, 6 … etc
up to 10,000.</p>

<p>To change the multiplier from the default of 1, we click a button.</p>

<p><div><script src='https://gist.github.com/e282df91443f92dc24345c136fd5e225.js'></script>
<noscript><pre><code>import React, { Component } from &#39;react&#39;
import &#39;./App.css&#39;
import ListItem from &#39;./ListItem&#39;

function arrayGenerator(length) {
  return Array.apply(null, { length: length }).map(Number.call, Number)
}

class App extends Component {
  constructor(props) {
    super(props)
    this.state = {
      multiplier: 1
    }
  }
  
  resetMultiplier() {
    this.setState({ multiplier: 2 })
  }

  render() {
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;button onClick={this.resetMultiplier.bind(this)}&gt;Click Me&lt;/button&gt;
        &lt;ul&gt;
          {
            arrayGenerator(5000).map(i =&gt; {
              return &lt;ListItem key={i} text={i}/&gt;
            })
          }
          {
            arrayGenerator(5000).map(i =&gt; {
              return &lt;ListItem key={i} text={i + this.state.multiplier}/&gt;
            })
          }
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}

export default App
</code></pre></noscript></div>
</p>

<p>When clicking the button, only the second array of ListItems should re-render —
only they are affected by the change. Yet we’re experiencing slowness, so we
want to investigate whether everything is as it should be.</p>

<h3>Measuring Update Time</h3>

<p>We’ll start by installing React’s performance tools.
<code>
npm install --save-dev react-addons-perf
</code>
And then we can import it in our App.js:
<code>javascript
    import Perf from 'react-addons-perf'
</code>
There are four Perf functions that we care about:</p>

<ul>
<li>Perf.start(): start measuring performance.</li>
<li>Perf.stop()</li>
<li>Perf.printExclusive(): prints total rendering time for components.</li>
<li>Perf.printWasted(): prints wasted renders- we’ll get to this shortly.</li>
</ul>


<p>We want to start measuring render time before our component starts updating-
before we call <em>setState()</em>. Then we can stop the measurement and print the
results using the lifecycle method <em>componentDidUpdate()</em>.</p>

<p><div><script src='https://gist.github.com/1d699da138bd651f1993127cc8028b70.js'></script>
<noscript><pre><code>  componentDidUpdate() {
    Perf.stop()
    Perf.printInclusive()
    Perf.printWasted()
  }

  resetMultiplier() {
    Perf.start()
    this.setState({ multiplier: 2 })
  }</code></pre></noscript></div>
</p>

<p>Here’s what our console will look like after clicking the button:</p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*SxJEEnK8C4sJTdIAnzvmVg.png" alt="" /></p>

<p>Our App renders took 94.75ms to render, and rendered only once.</p>

<p>Our ListItem component took 53.84ms, and rendered 10,000 times (this is
including all instances of the components, not individual render time).</p>

<p>In the second table, we can see ‘wasted’ time — when the component re-rendered
but nothing had actually changed.</p>

<p>We have 5,000 wasted ListItem renders. Not good.</p>

<p>These renders are ‘wasted’ in the sense that only the ListItems affected by the
multiplier will have their render actually changed when we click the button.
There’s no point in having them re-render.</p>

<h3>Fixing Wasted Renders</h3>

<p>Fortunately, React furnishes us with a handy lifecycle method called
<em>shouldComponentUpdate()</em> for these types of situations.</p>

<p>It gives us fine-grained control of when our component will re-render.</p>

<p>We can check for certain conditions, returning a boolean that React uses to
determine whether it will call <em>render()</em> on the component, or leave it as is.</p>

<p>Here’s what it would look like for ListItem:</p>

<p><div><script src='https://gist.github.com/35e739f94d338031acea59c04de42fbd.js'></script>
<noscript><pre><code>import React, { Component } from &#39;react&#39;

export default class ListItem extends Component {
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.text !== this.props.text  
  }

  render() {
    let { text } = this.props
    return &lt;li&gt;{text}&lt;/li&gt;
  }
}</code></pre></noscript></div>
</p>

<p>If the text prop hasn’t changed, there’s no reason to change the component’s
appearance via a re-render.</p>

<p><em>Note that we don’t use the nextState argument in shouldComponentUpdate()- I
left it there for reference.</em></p>

<p>Now let’s re-run our Perf.</p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*45uzx4SZL67IgaWNGmIM1A.png" alt="" /></p>

<p>We’ve cut our total render time down by 30ms, and eliminated all wasteful
renders.</p>

<h3>Using Perf in the Real World</h3>

<p>Most of the components you’ll be benchmarking won’t be nearly this simple. But
the Perf tools are a valuable way to identify which components are problems.</p>

<p>Here’s an example of <em>Perf.printWasted()</em> from MuseFind’s administrative table
component:</p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*2Drc_MtkAZexMuuXhBb4Vw.png" alt="" /></p>

<p>These wasted times aren’t long at all, thankfully — but you can see that of the
wasteful renders, the Header component is the main problem, with its
subcomponents Toolbar and PopoverMenu accounting for almost all of the wasted
render time.</p>

<p>Those two components are prime candidates for adding <em>shouldComponentUpdate()</em>.</p>

<h3>Bonus: Benchmarking Initial Renders</h3>

<p>Sometimes you want to not just benchmark when the component updates, but also
how long it takes to render completely the first time around.</p>

<p>In short, we want to measure the time between <em>componentWillMount() </em>and
<em>componentDidMount().</em></p>

<p><em>Perf.start()</em> can’t be placed in the <em>componentWillMount(), </em>however, so we’ll
have to be a little more manual.</p>

<p><div><script src='https://gist.github.com/4f4889a9c600ce31d6f48e2304d5f033.js'></script>
<noscript><pre><code>  componentWillMount() {
    window.performance.mark(&#39;App&#39;)
  }

  componentDidMount() {
    console.log(window.performance.now(&#39;App&#39;))
  }</code></pre></noscript></div>
</p>

<p>This will give you a logged out time in milliseconds- not as fancy as Perf, but
a useful metric for how long it takes to boot up your app.</p>

<h3>Final Notes</h3>

<p>As the docs page <a href="https://facebook.github.io/react/docs/perf.html">proudly
proclaims</a>, React is fast as it
is.</p>

<p>However, that doesn’t mean it’s free from performance slowdowns caused by
unnecessary re-renders — especially in complex apps with hundreds of children.</p>

<p>Using Perf on high-level components can give you an idea of which children are
the problem, so you can keep your app quick and snappy.</p>

<p>I hope this article has been useful — if it has, let me know by hitting the
green heart below.</p>

<p>If you have any questions or feedback, let me know in the comments — thanks for
reading.</p>

<p><a href="http://pwa-newsletter.com/">http://pwa-newsletter.com/</a></p>

<p>Want to stay up to date/learn best practices for the future of web development?
Say hello to Progressive Web App Newsletter — subscribe through the above link.</p>
]]></content>
  </entry>
  
</feed>
